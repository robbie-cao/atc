//=============================================================================
// File:			at_utsm.c
//
// Description:		AT SMS utilities
//
//==============================================================================

#define __AT_UTSM_C__

#include <stdio.h>
#include <stdlib.h>
#include "at_util.h"
#include "at_cfg.h"
#include "mstypes.h"
#include "atc.h"
#include "at_utsm.h"
#include "sim_api.h"
#include "taskmsgs.h"
#include "ms_database.h"
#include "util.h"
#include "osheap.h"

#ifndef _WIN32
#define sprintf _sprintf
#endif

extern void AtConvertTimeToString(UInt8* timeString, SmsAbsolute_t dateTime);

//---------------------------
// Alphabet conversion tables
//---------------------------
// move over from atc_cmap.h
//  This file was generated using utility mkcmap.c

const static UInt8 GsmToTeConvTbl_iso8859_1 [128] = {
0x40, 0xa3, 0x24, 0xa5, 0xe8, 0xe9, 0xfa, 0xec, 0xf2, 0xc7, 0x0a, 0xd8, 0xf8, 0x0d, 0xc5, 0xe5,
0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xc6, 0xe6, 0xdf, 0xca,
0x20, 0x21, 0x22, 0x23, 0xa4, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0xa1, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xc4, 0xd6, 0xd1, 0xdc, 0xa7,
0xbf, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0xe4, 0xf6, 0xf1, 0xfc, 0xe1,
} ;

const static UInt8 TeToGsmConvTbl_iso8859_1 [256] = {
0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x21, 0x22, 0x23, 0x02, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x11,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x40, 0x20, 0x01, 0x24, 0x03, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60,
0x20, 0x20, 0x20, 0x20, 0x5b, 0x0e, 0x1c, 0x09, 0x20, 0x20, 0x1f, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x5d, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x0b, 0x20, 0x20, 0x20, 0x5e, 0x20, 0x20, 0x1e,
0x20, 0x7f, 0x20, 0x20, 0x7b, 0x0f, 0x1d, 0x20, 0x04, 0x05, 0x20, 0x20, 0x07, 0x20, 0x20, 0x20,
0x20, 0x7d, 0x08, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x0c, 0x20, 0x06, 0x20, 0x7e, 0x20, 0x20, 0x20,
} ;

const static UInt8 GsmToTeConvTbl_iso8859_2 [128] = {
0x40, 0x20, 0x24, 0x20, 0x20, 0xe9, 0x20, 0x20, 0x20, 0xc7, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xdf, 0x20,
0x20, 0x21, 0x22, 0x23, 0xa4, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x20, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xc4, 0xd6, 0xd1, 0xdc, 0xa7,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0xe4, 0xf6, 0xf1, 0xfc, 0xe1,
} ;

const static UInt8 TeToGsmConvTbl_iso8859_2 [256] = {
0x01, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x21, 0x22, 0x23, 0x02, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x11,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x24, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x5b, 0x20, 0x20, 0x09, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x5d, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5e, 0x20, 0x20, 0x1e,
0x20, 0x7f, 0x20, 0x20, 0x7b, 0x20, 0x20, 0x20, 0x20, 0x05, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x7d, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7e, 0x20, 0x20, 0x20,
} ;

const static UInt8 GsmToTeConvTbl_iso8859_3 [128] = {
0x40, 0x20, 0x24, 0x20, 0xe8, 0xe9, 0xfa, 0xec, 0xf2, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xdf, 0xca,
0x20, 0x21, 0x22, 0x23, 0xa4, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x20, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xc4, 0xd6, 0xd1, 0xdc, 0xa7,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0xe4, 0xf6, 0xf1, 0xfc, 0xe1,
} ;

const static UInt8 TeToGsmConvTbl_iso8859_3 [256] = {
0x01, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x21, 0x22, 0x23, 0x02, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x11,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x24, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x5b, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1f, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x5d, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5e, 0x20, 0x20, 0x1e,
0x20, 0x7f, 0x20, 0x20, 0x7b, 0x20, 0x20, 0x20, 0x04, 0x05, 0x20, 0x20, 0x07, 0x20, 0x20, 0x20,
0x20, 0x7d, 0x08, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x20, 0x20, 0x06, 0x20, 0x7e, 0x20, 0x20, 0x20,
} ;

const static UInt8 GsmToTeConvTbl_iso8859_4 [128] = {
0x40, 0x20, 0x24, 0x20, 0x20, 0xe9, 0xfa, 0xed, 0x20, 0x20, 0x0a, 0xd8, 0xf8, 0x0d, 0xc5, 0xe5,
0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xc6, 0xe6, 0xdf, 0xc9,
0x20, 0x21, 0x22, 0x23, 0xa4, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x20, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xc4, 0xd6, 0xd1, 0xdc, 0xa7,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0xe4, 0xf6, 0xf1, 0xfc, 0xe1,
} ;

const static UInt8 TeToGsmConvTbl_iso8859_4 [256] = {
0x01, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x21, 0x22, 0x23, 0x02, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x11,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x24, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x5b, 0x0e, 0x1c, 0x20, 0x20, 0x1f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x5d, 0x20, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x0b, 0x20, 0x20, 0x20, 0x5e, 0x20, 0x20, 0x1e,
0x20, 0x7f, 0x20, 0x20, 0x7b, 0x0f, 0x1d, 0x20, 0x20, 0x05, 0x20, 0x20, 0x20, 0x07, 0x20, 0x20,
0x20, 0x7d, 0x20, 0x20, 0x20, 0x20, 0x7c, 0x20, 0x0c, 0x20, 0x06, 0x20, 0x7e, 0x20, 0x20, 0x20,
} ;

const static UInt8 GsmToTeConvTbl_iso8859_5 [128] = {
0x40, 0x20, 0x24, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0xb4, 0x5f, 0xc4, 0xb3, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x21, 0x22, 0x23, 0x20, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x20, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
} ;

const static UInt8 TeToGsmConvTbl_iso8859_5 [256] = {
0x01, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x21, 0x22, 0x23, 0x02, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x11,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x13, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x12, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
} ;

const static UInt8 GsmToTeConvTbl_iso8859_6 [128] = {
0x40, 0x20, 0x24, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x21, 0x22, 0x23, 0x20, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x20, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
} ;

const static UInt8 TeToGsmConvTbl_iso8859_6 [256] = {
0x01, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x20, 0x0d, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x21, 0x22, 0x23, 0x02, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x11,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
} ;



//
//  -- PCCP 437 ---
//
const static UInt8 TeToGsmConvTbl_pccp_437 [] =
{
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x0a,0x20,0x20,0x0d,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x5f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x21,0x22,0x23,0x02,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x00,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x20,0x20,0x20,0x20,0x11,
0x20,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x20,0x20,0x20,0x20,0x20,
0x09,0x7e,0x05,0x61,0x7b,0x7f,0x0f,0x09,0x65,0x65,0x04,0x69,0x69,0x07,0x5b,0x0e,
0x1f,0x1d,0x1c,0x6f,0x7c,0x08,0x75,0x06,0x79,0x5c,0x5e,0x20,0x01,0x03,0x20,0x20,
0x61,0x69,0x6f,0x75,0x7d,0x5d,0x20,0x20,0x60,0x20,0x20,0x20,0x20,0x40,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x1e,0x13,0x20,0x18,0x20,0x20,0x20,0x12,0x19,0x15,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
};

const static UInt8 GsmToTeConvTbl_pccp_437 [] =
{
0x40,0x9c,0x24,0x9d,0x8a,0x82,0x97,0x8d,0x95,0x80,0x0a,0x4f,0x6f,0x0d,0x8f,0x86,
0x20,0x5f,0xe8,0xe2,0x20,0xea,0xe3,0x20,0xe4,0xe9,0x20,0x20,0x92,0x91,0xe1,0x90,
0x20,0x21,0x22,0x23,0x20,0x25,0x26,0X27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0xad,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x8e,0x99,0xa5,0x9a,0x15,
0xa8,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0X74,0X75,0X76,0X77,0x78,0x79,0x7a,0x84,0x94,0xa4,0x81,0x85
};

UInt8* atc_GetGsmToTeConvTbl ( void )
{
    char* cscs = (char*) MS_GetCfg()->CSCS ;

    if ( !strcmp ( cscs, "GSM" ) )
    {
      return NULL ;
    }
    else if ( !strcmp ( cscs, "8859-1" ) )
    {
      return (UInt8*)GsmToTeConvTbl_iso8859_1 ;
    }
    else if ( !strcmp ( cscs, "8859-2" ) )
    {
      return (UInt8*)GsmToTeConvTbl_iso8859_2 ;
    }
    else if ( !strcmp ( cscs, "8859-3" ) )
    {
      return (UInt8*)GsmToTeConvTbl_iso8859_3 ;
    }
    else if ( !strcmp ( cscs, "8859-4" ) )
    {
      return (UInt8*)GsmToTeConvTbl_iso8859_4 ;
    }
    else if ( !strcmp ( cscs, "8859-5" ) )
    {
      return (UInt8*)GsmToTeConvTbl_iso8859_5 ;
    }
    else if ( !strcmp ( cscs, "8859-6" ) )
    {
      return (UInt8*)GsmToTeConvTbl_iso8859_6 ;
    }
    else
    {
      return (UInt8*)GsmToTeConvTbl_pccp_437 ;
    }
}

UInt8* atc_GetTeToGsmConvTbl ( void )
{
    char* cscs = (char*) MS_GetCfg()->CSCS ;

    if ( !strcmp ( cscs, "GSM" ) )
    {
      return NULL ;
    }
    else if ( !strcmp ( cscs, "8859-1" ) )
    {
      return (UInt8*)TeToGsmConvTbl_iso8859_1 ;
    }
    else if ( !strcmp ( cscs, "8859-2" ) )
    {
      return (UInt8*)TeToGsmConvTbl_iso8859_2 ;
    }
    else if ( !strcmp ( cscs, "8859-3" ) )
    {
      return (UInt8*)TeToGsmConvTbl_iso8859_3 ;
    }
    else if ( !strcmp ( cscs, "8859-4" ) )
    {
      return (UInt8*)TeToGsmConvTbl_iso8859_4 ;
    }
    else if ( !strcmp ( cscs, "8859-5" ) )
    {
      return (UInt8*)TeToGsmConvTbl_iso8859_5 ;
    }
    else if ( !strcmp ( cscs, "8859-6" ) )
    {
      return (UInt8*)TeToGsmConvTbl_iso8859_6 ;
    }
    else
    {
      return (UInt8*)TeToGsmConvTbl_pccp_437 ;
    }
}


//------------------------------------------------------------------------------
//
// Function Name:       atc_8To7bit
//
// Description:         converts an 8-bit coded string into a 7-bit coded buffer
// Note :
//        Input buffer is overwritten with output buffer.
// Returns the nb of bytes of the output buffer
//------------------------------------------------------------------------------
UInt8 atc_8To7bit( UInt8 *Str,
                  UInt8 StrLen  // Nb of bytes in the source buffer
                 )
{
 UInt8 OutIdx = 0 ; // Index in the Str for the output
 UInt8 InIdx = 0;
 UInt8 NbChar = 0; // Nb of converted chars
 UInt8 PrevBits = 0; // Nb of Bits to store on previous byte

 for (NbChar=0 ; NbChar < StrLen ; NbChar++)
    {
    Str[OutIdx] = Str[InIdx];

    if (PrevBits)
       {
       Str[OutIdx-1] |= (Str[OutIdx] << (8-PrevBits) );
       }

    if (PrevBits !=7)
       {
       Str[OutIdx] >>= PrevBits ;
       OutIdx++;
       PrevBits++;
       }

    else
       {
       PrevBits = 0;
       }

    InIdx++;
    }

 return (OutIdx);
}

//------------------------------------------------------------------------------
//
// Function Name:       atc_7To8bit
//
// Description:         converts a 7-bit coded buffer into an 8-bit coded string
// Note : destination buffer must have been allocated by caller
//
//------------------------------------------------------------------------------
void atc_7To8bit( UInt8 *Dst,   // Pointer to the dest buffer
                  UInt8 *Src,   // Pointer to the source buffer
                  UInt8 NbDigits// Nb of digits in the source buffer
                 )

{
 UInt8 NbChar   = 0; // Nb of output characters
 UInt8 MaskSize = 7;

 while (NbChar < NbDigits)
    {
    UInt8 Mask;
    UInt8 Shift;

    Shift = MaskSize +1;

    // 7-bit Character is right aligned
    if (Shift==8)
       {
       Shift = 0;
       }

    // Get bits on first octet
    Dst[NbChar]  = ((*Src) >> Shift) & 0x7F;

    // Get bits on second if necessary
    if (Shift)
       {
       Src ++;
       Shift = 8 - Shift ;
       Mask  = (1 << MaskSize) - 1;
       Dst[NbChar] |= ((*Src) & Mask) << Shift;
       }

    NbChar ++;
    if ( MaskSize == 0 )
       {
       MaskSize = 7;
       }
    else
       {
       MaskSize--;
       }
    }
}


//*************** decoding and conversions from 3.40 to TE *********************
//------------------------------------------------------------------------------
//
// Function Name:       AT_FormatUdForTe
//
// Description:         converts a 3.40/3.41 TP-User Data into an ascii string
//
// Note :
//                      Output is terminated with a '\0'
//
//------------------------------------------------------------------------------
void AT_FormatUdForTe(UInt8 *Out, UInt8* ud, UInt8 udl, SmsDcs_t* dcs, Boolean udhi, UInt8 udh1)
{
	UInt8 *Src;
	const UInt8 *ConvTable;

	Src = ud;

	if ( (udhi && (udh1 != 0)) || (dcs->Compression == TRUE) || (dcs->MsgAlphabet == SMS_ALPHABET_UCS2) )
	{
		UTIL_HexDataToHexStr(Out, Src, udl);
		Out[2 * udl] = '\0';   // ends the output string with NULL
	}
	else
	{
		UInt8 i;
		ConvTable = atc_GetGsmToTeConvTbl();

		if (ConvTable != NULL){
			for (i = 0; i < udl; i++) {
				Out[i] = ConvTable[Src[i]];
			}
			Out[udl] = '\0';   /* ends the output string with NULL */
		}
		else{
			i = atc_8To7bit(Src, udl);
			memcpy(Out, Src, i);
			Out[i] = '\0';
		}
	}
}

//------------------------------------------------------------------------------
//
// Function Name:       AT_OutMsg2Te
//
// Description:         Concats SMS PP in text display format,
//                      at the end of Out Buffer
// Notes:
//
//------------------------------------------------------------------------------
UInt16 AT_OutMsg2Te(UInt8* Out, SmsSimMsg_t *In, AT_CmdId_t cmdId)
{
    UInt16 Res = 0;
    Boolean IsUdPresent = TRUE ;
	SmsDcs_t dcs;
	Boolean udhi;

	UInt8 sctsString[20+1];
	UInt8 dtString[20+1];

	// message status
	sprintf((char *)&Out[strlen((char *)Out)], "\"%s\",", atc_SmsStateText[In->status]);

	switch (In->msgTypeInd)
	{
		case SMS_DELIVER :
			// <oa>
			sprintf((char *)&Out[strlen((char *) Out)], "\"%s\",", In->daoaAddress.Number);
			AtConvertTimeToString(sctsString, In->msg.msgRxData.srvCenterTime.absTime);

			// <scts>
			if (In->msg.msgRxData.srvCenterTime.isRelativeTime == FALSE)
			{
				sprintf((char *)&Out[strlen((char *) Out)], ",\"");
				strcpy((char *)&Out[strlen((char *) Out)], (char *)sctsString);
				sprintf((char *)&Out[strlen((char *) Out)], "\"");
			}
			else // who knows?
			{
				Res = 500; // unknown error
				_TRACE(("SMS: AT_OutMsg2Te: RelTime = TRUE"));
				return(Res);
			}

			// show tooa, fo, pid, dcs, sca, tosca and length
			if (GET_CSDH)
			{
				sprintf((char *)&Out[strlen((char *) Out)],",%d",
							In->daoaAddress.TypeOfAddress);

				if (cmdId == AT_CMD_CMGR)
				{
					sprintf((char *) &Out[strlen((char *)Out)], ",%d,%d,%d,\"%s\",%d",
							In->msg.msgRxData.fo,
							In->msg.msgRxData.procId,
							In->msg.msgRxData.codingScheme.DcsRaw,
							In->msg.msgRxData.ServCenterAddress.Number,
							In->msg.msgRxData.ServCenterAddress.TypeOfAddress);
				}
				sprintf((char *)&Out[strlen((char *)Out)],",%d", In->textLen);
			}

			memcpy(&dcs, &In->msg.msgRxData.codingScheme, sizeof(SmsDcs_t));
			udhi = In->msg.msgRxData.usrDataHeaderInd;
			break;  // end SMS_DELIVER

		case ATC_SMS_SUBMIT :
			{
			SmsAddress_t sca;
			Result_t res;

			if(In->msg.msgTxData.codingType.msgClass == 0xFF)
			{
				dcs.DcsRaw = (In->msg.msgTxData.codingType.alphabet & 0x03)<<2;
			}
			else
			{
				dcs.DcsRaw = ((In->msg.msgTxData.codingType.alphabet & 0x03)<<2) |
							 ((In->msg.msgTxData.codingType.msgClass) &0x03) | (1<<4);
			}

			SMS_DecDcs(&dcs);

			udhi = In->msg.msgTxData.userDataHeaderInd;

			// <da>
			sprintf((char *)&Out[strlen((char *)Out)], "\"%s\",",
					In->daoaAddress.Number);

			// show toda, fo, pid, dcs, vp, sca, tosca and length
			if (GET_CSDH)
			{
				sprintf((char *)&Out[strlen((char *)Out)],",%d",
						In->daoaAddress.TypeOfAddress);

				if (cmdId == AT_CMD_CMGR)
				{
					UInt8 Fo;

					Fo = SMS_SET_MTI(SUBMIT_340);
					Fo |= SMS_SET_RD   (In->msg.msgTxData.rejDupl);
					Fo |= SMS_SET_VPF  (2);  // only relative is supported
					Fo |= SMS_SET_SRR  (In->msg.msgTxData.statusRptRequest);
					Fo |= SMS_SET_UDHI (In->msg.msgTxData.userDataHeaderInd);
					Fo |= SMS_SET_RP   (In->msg.msgTxData.replyPath);

					sprintf((char *)&Out[strlen((char *)Out)], ",%d,%d,%d,",
							Fo,
							In->msg.msgTxData.procId,
							dcs.DcsRaw);

					if (In->msg.msgTxData.validatePeriod.isRelativeTime == TRUE)
					{
						sprintf((char *) &Out[strlen((char *) Out)], "%d",
						 In->msg.msgTxData.validatePeriod.relTime.time);
					}
					else
					{
						// not supported
						//sprintf((char *)&Out[strlen((char *) Out)], "\"");
						//strcpy((char *)&Out[strlen((char *) Out)],
						//		(char *)In->msg.msgTxData.validatePeriod.Time);
						//sprintf((char *)&Out[strlen((char *) Out)], "\"");
					}

					res = SMS_GetSMSrvCenterNumber(&sca, USE_DEFAULT_SCA_NUMBER);

					if(res == RESULT_OK){
						sprintf((char *)&Out[strlen((char *)Out)],",\"%s\",%d",
							sca.Number, sca.TypeOfAddress);
					}
					else{
						sprintf((char *)&Out[strlen((char *)Out)],",\"\",");
					}
				}

				sprintf((char *)&Out[strlen((char *)Out)],",%d", In->textLen);
			}
			}
			break;

		case ATC_SMS_STATUS_REPORT :
			AtConvertTimeToString(sctsString, In->msg.msgSrData.srvCenterTime.absTime);
			AtConvertTimeToString(dtString, In->msg.msgSrData.discardTime.absTime);

			sprintf((char *)&Out[strlen((char *)Out)],
					"%d,%d,\"%s\",%d,\"%s\",\"%s\",%d",
					In->msg.msgSrData.fo,
					In->msg.msgSrData.msgRefNum,
					In->daoaAddress.Number,
					In->daoaAddress.TypeOfAddress,
					(char *) sctsString,
					(char *) dtString,
					In->msg.msgSrData.status);

			IsUdPresent = FALSE ;
			break;

		default :
			Res = 303; // operation not supported
			return(Res);
	}

	// <CR><LF>
	sprintf((char *) &Out[strlen((char *) Out)], "\r\n");

	// User Data
	if (IsUdPresent == TRUE)
	{
		AT_FormatUdForTe((UInt8 *)&Out[strlen((char *)Out)], In->text_data, In->textLen, &dcs, udhi, In->udhData[0]);
	}

	return(0);
}


//************************ from SMS to TE ***********************************

//******************************************************************************
//
// Function Name:      *atc_RmvBackSpace
//
// Description:        Remove Back space and delete the corresponding number of
//                     character the a string.
//
// Notes:
//
//******************************************************************************
UInt8 *atc_RmvBackSpace (UInt8 *Str)
{
 UInt8 *Char;
 UInt16 i, j;
 UInt32 l;

 Char = Str;
 i = j = 0;

 l = strlen((char *)Str);
 while (i <= l)
 {
  if (Char [i] != 8)
  {
   if (i != j)
    Char [j] = Char [i];

   j++;
  }
  else
  {
   while ((Char [i+1] == 8)
   &&     (j > 0))
   {
    j--;
    i++;
   }

   if (j > 0)
    Char [j-1] = Char [i+1];
   else
    Char [j++] = Char [i+1];

   i++;
  }
  i++;

 }
// Char [j] = 0;

 return Str;
}


//******************************************************************************
// Datas for unsollicited response buffer management.
//******************************************************************************

#define ATC_MAX_UNSOL_RSP_BUFFERED  10

void *atc_UnsollicitedRspBuffer [ATC_MAX_UNSOL_RSP_BUFFERED]
     = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
atc_BufferedURsp_t  atc_UnsollicitedRspType [ATC_MAX_UNSOL_RSP_BUFFERED];

UInt8 atc_URspFillIdx  = 0;
UInt8 atc_URspPurgeIdx = 0;



//******************************************************************************
//
// Function Name:      atc_PurgeURspBuffer
//
// Description:        Delete all unsollicited response buffered.
//
// Notes:
//
//******************************************************************************
void atc_PurgeURspBuffer (void)
{
 UInt8 i;

 for (i = 0; i < ATC_MAX_UNSOL_RSP_BUFFERED; i++)
 {
  if (atc_UnsollicitedRspBuffer [i])
   OSHEAP_Delete( atc_UnsollicitedRspBuffer [i] );
  atc_UnsollicitedRspBuffer [i] = NULL;
 }
 atc_URspFillIdx  = 0;
 atc_URspPurgeIdx = 0;

}

//******************************************************************************
//
// Function Name:      atc_CleanUBufferType
//
// Description:        Apply Mask on Unsollicited buffer type.
//
// Notes:
//
//******************************************************************************
void atc_CleanUBufferType (UInt8 Mask)
{
 UInt8 i;

 for (i = 0; i < ATC_MAX_UNSOL_RSP_BUFFERED; i++)
 {
  atc_UnsollicitedRspType [i] &= ~Mask;
 }

}

//******************************************************************************
//
// Function Name:      atc_SetNewURspInBuffer
//
// Description:        Store a new unsollicited response in buffer.
//
// Notes:              If buffer is full, oldest response is deleted, then
//                     the function return 1, 0 otherwise.
//
//******************************************************************************
UInt8 atc_SetNewURspInBuffer (void *Rsp, UInt16 Size, atc_BufferedURsp_t Type)
{
 void *Ptr = OSHEAP_Alloc ( Size );
 UInt8 RetValue = 0;

 memcpy ( (char *) Ptr, (char *) Rsp, Size );

 if (atc_UnsollicitedRspBuffer [atc_URspFillIdx] == NULL)
 {
  atc_UnsollicitedRspBuffer [atc_URspFillIdx] = Ptr;
 }
 else  /* Purge older Rsp stored. */
 {
  /* In this case, atc_URspPurgeIdx should be equal to atc_URspFillIdx. */
  /* So increase PurgeIdx by one and free Rsp on purge Idx.             */

  if (++atc_URspPurgeIdx >= ATC_MAX_UNSOL_RSP_BUFFERED)
   atc_URspPurgeIdx = 0;

  OSHEAP_Delete( atc_UnsollicitedRspBuffer [atc_URspFillIdx] );
  atc_UnsollicitedRspBuffer [atc_URspFillIdx] = Ptr;
  RetValue = 1;
 }

 atc_UnsollicitedRspType [atc_URspFillIdx] = Type;

 if (++atc_URspFillIdx >= ATC_MAX_UNSOL_RSP_BUFFERED)
  atc_URspFillIdx = 0;

 return RetValue;
}

//******************************************************************************
//
// Function Name:      *atc_GetOldestURspFromBuffer
//
// Description:        Return the oldest unsollicited response buffered.
//
// Notes:
//
//******************************************************************************
void *atc_GetOldestURspFromBuffer (atc_BufferedURsp_t *Type)
{
 void *Ptr = atc_UnsollicitedRspBuffer [atc_URspPurgeIdx];
 *Type = atc_UnsollicitedRspType [atc_URspPurgeIdx];

 atc_UnsollicitedRspBuffer [atc_URspPurgeIdx] = NULL;

 /* Increase Purge Index only if Rsp is return. */
 if (Ptr != NULL)
 {
  if (++atc_URspPurgeIdx >= ATC_MAX_UNSOL_RSP_BUFFERED)
   atc_URspPurgeIdx = 0;
 }
 return Ptr;
}

//******************************************************************************
//
// Function Name:      GetNumMsgsForEachBox
//
// Description:
//
//
//******************************************************************************
Boolean GetNumMsgsForEachBox(SmsStorage_t storageType, msgNumInBox_t* msgNumInBox)
{
	UInt8 i;
	SIMSMSMesgStatus_t status;

	msgNumInBox->num1 = 0;
	msgNumInBox->num2 = 0;
	msgNumInBox->num3 = 0;
	msgNumInBox->num4 = 0;

	for (i=0; i < SMS_GetSmsMaxCapacity(storageType); i++)
	{
		if(SMS_GetSmsStoredState(storageType, i, &status) != RESULT_OK)
			return FALSE;

		switch(status)
		{
			case SIMSMSMESGSTATUS_UNREAD:
				msgNumInBox->num1++;
				break;

			case SIMSMSMESGSTATUS_READ:
				msgNumInBox->num2++;
				break;

			case SIMSMSMESGSTATUS_UNSENT:
				msgNumInBox->num3++;
				break;

			case SIMSMSMESGSTATUS_SENT:
				msgNumInBox->num4++;
				break;

			default:
				break;
		}
	}

	return TRUE;
}


//******************************************************************************
//
// Function Name:  atc_SetCnmaTpMti, atc_GetCnmaTpMti, atc_ResetCnmaTpMtiFiFo
//
// Description:
//
// Notes:
//
//
//******************************************************************************
#define ATC_CNMA_FIFO_DIM 16
UInt8 CnmaMtiFiFo [ ATC_CNMA_FIFO_DIM ];
UInt8 IdxStartCnmaMtiFiFo = 0;
UInt8 IdxStopCnmaMtiFiFo = 0;

void atc_SetCnmaTpMti (UInt8 TpMti)
{
 CnmaMtiFiFo [(IdxStartCnmaMtiFiFo++) & (ATC_CNMA_FIFO_DIM - 1)] = TpMti;
}

UInt8 atc_GetCnmaTpMti (void)
{
 return CnmaMtiFiFo [(IdxStopCnmaMtiFiFo++) & (ATC_CNMA_FIFO_DIM - 1)];
}

void atc_ResetCnmaTpMtiFiFo (void)
{
 IdxStartCnmaMtiFiFo = 0;
 IdxStopCnmaMtiFiFo = 0;
}

/* At a given time only one Sms wait for acknoledgment. */
Timer_t CnmaTimerFiFo = NULL;

void atc_ResetCnmaDataBase (void)
{
 atc_SmsWaitedCnma = 0;
 atc_NextCmdIsCnma = 0;
 atc_SendRpAck     = 0;
 SMS_SetNewMsgDisplayPref(SMS_MT, 0);
 SMS_SetNewMsgDisplayPref(SMS_DS, 0);
 /* No more acknowledment are waited so clean Unsolicited buffer type. */
 atc_CleanUBufferType (RP_ACK_MSK);
 atc_ResetCnmaTpMtiFiFo ();
 atc_ResetCnmaTimerFiFo ();
}


void atc_CnmaTimerEvent ( TimerID_t Id )
{
	InterTaskMsg_t*		msg;

	msg = AllocInterTaskMsgFromHeap(MSG_SMS_CNMA_TIMER_IND, sizeof(TimerID_t));

	*(TimerID_t*)msg->dataBuf = Id;

	PostMsgToATCTask(msg);

}


// atc_CnmaTimer_CB
void AtHandleSmsCnmaTimerEvent(InterTaskMsg_t* inMsg)
{
	T_MN_TP_STATUS_RSP *StatusRsp = (T_MN_TP_STATUS_RSP *)OSHEAP_Alloc(sizeof(T_MN_TP_STATUS_RSP) );
	TimerID_t Id = *(TimerID_t *)inMsg->dataBuf;

	/* Cnma timer occurs before cnma command, so Send Nack. */
	StatusRsp -> tp_mti   = (T_MN_MESSAGE_TYPE_INDICATOR) (Id & 0xFF);
	StatusRsp -> rp_cause = MN_SMS_PROTOCOLL_ERROR;
	StatusRsp -> tp_fcf   = FALSE;
	StatusRsp -> tp_fcs   = TP_FCS_NO_ERROR;
	MNSMS_SMResponse( StatusRsp );

	atc_ResetCnmaDataBase ();
}

void atc_SetCnmaTimer (UInt8 TpMti)
{
 CnmaTimerFiFo  =

 OSTIMER_Create( atc_CnmaTimerEvent,
                 (TimerID_t)(0xAA000000 | TpMti),
                 RP_ACK_TIMER,
                 0);

 OSTIMER_Start(CnmaTimerFiFo);
}

Boolean atc_GetCnmaTimer (void)
{
 Boolean Ret = FALSE;
 if (CnmaTimerFiFo != NULL)
 {
  OSTIMER_Destroy( CnmaTimerFiFo );
  Ret = TRUE;
 }
 CnmaTimerFiFo = NULL;
 return Ret;
}

void atc_ResetCnmaTimerFiFo (void)
{
 if (CnmaTimerFiFo != NULL)
  OSTIMER_Destroy( CnmaTimerFiFo );
}


/********************************* SMS CB utilities ***************************/
//------------------------------------------------------------------------------
//
// Function Name:       atc_DecCbDcs
//
// Description:         expands dcs 3.41 raw byte into an atc_SmsCbDcs_t
//                      structure
// Input:               Dcs->DcsRaw must be set by caller
// Return CMS error code if DCS non supported
//
//------------------------------------------------------------------------------
UInt16 atc_DecCbDcs(atc_SmsCbDcs_t *Dcs)
{
	UInt16 Res      = 0 ;
	UInt8 DcsRaw    = Dcs->DcsRaw;
	UInt8 CodingGrp = ATC_GET_CODING_GRP(DcsRaw);

	Dcs->Compression = FALSE ;

	switch (CodingGrp)
	{
		case 0x0F :
			Dcs->MsgAlphabet = (atc_SmsAlphabet_t)((DcsRaw & 0x0C) >> 2);
			Dcs->CodingGrp = MSG_DATA_CODING_MSGCLASS_GRP;
			Dcs->MsgClass  = (atc_SmsMsgClass_t) (DcsRaw & 0x03);
			break;

		case 0x0E :
			Dcs->CodingGrp = WAP_CODING_GRP;
			break;

		// General data coding group
		case 7 :
		case 6 :
		case 5 :
		case 4 :
			Dcs->CodingGrp   = GENERAL_DATA_CODING_GRP;
			if (DcsRaw & 0x20)
				Dcs->Compression = TRUE;

			if (DcsRaw & 0x10)
				Dcs->MsgClass = (atc_SmsMsgClass_t) (DcsRaw & 0x03);
			else
				Dcs->MsgClass = MSG_NO_CLASS;

			Dcs->MsgAlphabet = (atc_SmsAlphabet_t)((DcsRaw & 0x0C) >> 2);
			break;

		case 3 :
			Dcs->CodingGrp = DEFAULT_LANG3_CODING_GRP;
			Dcs->MsgAlphabet  = ATC_ALPHABET_DEFAULT;
			Dcs->Language  = ATC_LANG_EUROP;
			break ;

		case 2 :
			Dcs->CodingGrp = DEFAULT_LANG2_CODING_GRP;
			Dcs->MsgAlphabet  = ATC_ALPHABET_DEFAULT;
			Dcs->Language  = (DcsRaw & 0x0f) ? ATC_LANG_EUROP : ATC_LANG_CZECH;
			break ;

		case 1 :
			Dcs->CodingGrp = DEFAULT_LANG1_CODING_GRP;
			if ((DcsRaw & 0x0f) == 0){
				Dcs->MsgAlphabet  =  ATC_ALPHABET_DEFAULT;
				Dcs->Language  =  ATC_LANG_CODED;
			}

			if ((DcsRaw & 0x0f) == 1){
				Dcs->MsgAlphabet  =  ATC_ALPHABET_UCS2;
				Dcs->Language  =  ATC_LANG_CODED;
			}
			else{
				Dcs->MsgAlphabet  = ATC_ALPHABET_DEFAULT;
				Dcs->Language  = ATC_LANG_EUROP;
			}
			break ;

		case 0 :
			Dcs->CodingGrp = DEFAULT_LANG0_CODING_GRP;
			Dcs->MsgAlphabet  = ATC_ALPHABET_DEFAULT;
			Dcs->Language  = (atc_SmsLanguage_t)DcsRaw & 0x0f;

		default : // reserved coding groups
			Dcs->CodingGrp   = DEFAULT_LANG0_CODING_GRP;
			Dcs->MsgAlphabet = ATC_ALPHABET_DEFAULT;
			Dcs->Language    = ATC_LANG_EUROP;
			break;
	} // Coding group

//	if ((Dcs->Language == ATC_LANG_CODED) || (Dcs->Compression == TRUE)){
	if (Dcs->Compression == TRUE){
		_TRACE(("SMS: atc_DecCbDcs: Language = ", Dcs->Language));
		_TRACE(("SMS: atc_DecCbDcs: Compression = ", Dcs->Compression));
		Res = 303 ; // unsupported operation
	}

	return(Res);
}


//------------------------------------------------------------------------------
//
// Function Name:       atc_SmsCbGetPage
//
// Description:         returns a pointer to the requested CB page
//                      in the input CB message
// Notes:
// Returns NULL if page number is too big
//
//------------------------------------------------------------------------------
UInt8 *atc_SmsCbGetPage (UInt8 Page, T_SMS_CB_MSG *CbMsg)
{
 if ((Page == 0) || (Page > CbMsg->pages))
    {
    return (NULL);
    }
 else
    {
    return (CbMsg->msg.A + ((Page - 1) * CB_DATA_PER_PAGE_SZ));
    }
}

//------------------------------------------------------------------------------
//
// Function Name:       atc_FormatCbPageForTe
//
// Description:         converts a 3.41 CP Page Data into an ascii string
//                      in the TE selected alphabet
// Note :
//                      Output is terminated with a '\0'
//
//------------------------------------------------------------------------------
void atc_FormatCbPageForTe(UInt8 * Out, atc_SmsCbPage_t * In)
{
	UInt8 *Src;
	UInt8 TmpBuf[160];
	UInt8 i;
	UInt16 tmp;

	if(In->Dcs.CodingGrp == DEFAULT_LANG1_CODING_GRP){ // GSM3.38 section 5
		if(In->Dcs.MsgAlphabet == ATC_ALPHABET_DEFAULT){
			if ( (In->Dcs.Compression == FALSE) &&
				 (In->Dcs.MsgAlphabet == ATC_ALPHABET_DEFAULT) &&
				 strcmp((char*) MS_GetCfg()->CSCS, "GSM") ){

				atc_7To8bit( TmpBuf, &In->Ud[3], In->UdNbChar);	// ISO 639
				Src = TmpBuf;
			}
			else{
				Src = &In->Ud[3];	// ISO 639
			}
			_TRACE(("SMS CB: DEFAULT_LANG1_CODING_GRP: DEF CH[0]: ", In->Ud[0]));
			_TRACE(("SMS CB: DEFAULT_LANG1_CODING_GRP: DEF CH[1]: ", In->Ud[1]));
			_TRACE(("SMS CB: DEFAULT_LANG1_CODING_GRP: DEF CH[2]: ", In->Ud[2]));
		}
		else if(In->Dcs.MsgAlphabet == ATC_ALPHABET_UCS2){
			Src = &In->Ud[2];	// ISO 639
			_TRACE(("SMS CB: DEFAULT_LANG1_CODING_GRP: UCS2 CH[0]: ", In->Ud[0]));
			_TRACE(("SMS CB: DEFAULT_LANG1_CODING_GRP: UCS2 CH[1]: ", In->Ud[1]));
		}
		else{
			// reserved code, should not be used
			_TRACE(("SMS CB: Reserved DCS code, not processed."));
		}
	}
	else{
		/*
		** expand 7-bit SMS to 8-bit data if necessary
		*/
		if ( (In->Dcs.Compression == FALSE) &&
			 (In->Dcs.MsgAlphabet == ATC_ALPHABET_DEFAULT) &&
			 strcmp((char*) MS_GetCfg()->CSCS, "GSM") ){

			atc_7To8bit( TmpBuf, In->Ud, In->UdNbChar);
			Src = TmpBuf;
		}
		else{
			Src = In->Ud;
		}
	}

	/*
	** conversion
	*/
	// MCE, tbc (compression)
	if(In->Dcs.Compression == TRUE){
		UTIL_HexDataToHexStr(Out, Src, In->UdNbChar);
		Out[2 * In->UdNbChar] = '\0';   /* ends the output string with NULL */
	}
	else{
		const UInt8 *ConvTable;

		switch(In->Dcs.MsgAlphabet)
		{
			case ATC_ALPHABET_DEFAULT:
				ConvTable = atc_GetGsmToTeConvTbl();

				if (ConvTable != NULL)
				{
					for (i = 0; i < In->UdNbChar; i++)
					{
						Out[i] = ConvTable[Src[i]];
					}
					Out[In->UdNbChar] = '\0';   /* ends the output string with NULL */
				}
				else
				{
					/* The chosen character set is GSM default alphabet (channelCfg->CSCS is "GSM"),
					* so we can just copy the data without transformation, but first need
					* to determine the number of bytes to copy as GSM default alphabet uses
					* 7-bit encoding.
					*/
					tmp = In->UdNbChar * 7;
					i = (tmp / 8) + ((tmp % 8 == 0) ? 0 : 1);
					memcpy(Out, Src, i);
					Out[i] = '\0';
				}

				break;

			case ATC_ALPHABET_8BIT:
				ConvTable = atc_GetTeToGsmConvTbl();

				if (ConvTable != NULL)
				{
					for (i = 0; i < In->UdNbChar; i++)
					{
						Out[i] = ConvTable[Src[i]];
					}
					Out[In->UdNbChar] = '\0';   /* ends the output string with NULL */
				}
				else
				{
					/* The chosen character set is GSM default alphabet (channelCfg->CSCS is "GSM"),
					* so we need to shrink the 8-bit data to 7-bit characters.
					*/
					i = atc_8To7bit(Src, In->UdNbChar);
					memcpy(Out, Src, i);
					Out[i] = '\0';
				}

				break;

			default :
				UTIL_HexDataToHexStr(Out, Src, In->UdNbChar);
				Out[2 * In->UdNbChar] = '\0';   /* ends the output string with NULL */
				break;
		}
	}
}



//------------------------------------------------------------------------------
//
// Function Name:       atc_DecCbPage
//
// Description:         Expands a GSM 3.41 SMS CB Page
//                      to an atc_SmsCbPage_t
// Notes:
//
//  CB User Info is not copied, the buffer containing it must not be released
//  before TP-UD has been used
//
//  Return 0 if decoding OK, CMS error code otherwise.
//------------------------------------------------------------------------------
UInt16 atc_DecCbPage(atc_SmsCbPage_t * Out, StoredSmsCb_t * In)
{
	UInt16 Res = 0;

	// One decodes the whole page. If GSM alphabet, padding chars will
	// output space characters (hopefully).
	// If 8 bit alphabet, 0x00 will end the output
	Out->DataLen = CB_DATA_PER_PAGE_SZ;

	Out->Dcs.DcsRaw = In->Dcs;
	Res = atc_DecCbDcs (&Out->Dcs);

_TRACE(("SMS: atc_DecCbPage: Res = ", Res));

	if (Out->Dcs.MsgAlphabet == ATC_ALPHABET_DEFAULT)
		Out->UdNbChar = (Out->DataLen << 3) / 7;
	else
		Out->UdNbChar = Out->DataLen ;

	Out->Ud = In->Msg;

	return(Res);
}

//------------------------------------------------------------------------------
//
// Function Name:       atc_DisplaySmsCbPage
//
// Description:         decode and display an incoming T_MN_CB_MSG page
//
// Notes:
// returns CMS error code
//
//------------------------------------------------------------------------------
UInt16 atc_DisplaySmsCbPage ( UInt8 chan,
							  char * CurAtCmd,
                              UInt8 * Out,
                              StoredSmsCb_t * In,
                              SIMSMSMesgStatus_t Status)
{
	atc_SmsCbPage_t DecCbPage ;
	UInt16 Res = 0;
	AT_ChannelCfg_t* channelCfg;

	if(chan != INVALID_MPX_CHAN)
		channelCfg = AT_GetChannelCfg(chan);	// from a read command
	else
		channelCfg = AT_GetChannelCfg(0);		// from a unsolicited event

	Res = atc_DecCbPage (&DecCbPage, In);

	if(Res)
		return(Res);

	// Text mode
	if (channelCfg->CMGF)
	{
		// show message status
		if (strcmp(CurAtCmd, "+CBM"))
			sprintf ((char *) &Out[strlen((char *) Out)], "\"%s\",", atc_SmsStateText[Status]);

		sprintf((char *) &Out[strlen((char *) Out)], "%d,", In->Serial);
		sprintf((char *) &Out[strlen((char *) Out)], "%d,", In->MsgId);

		if ((!strcmp(CurAtCmd, (char*)AT_GetCmdName(AT_CMD_CMGR))) ||
			(!strcmp(CurAtCmd, "+CBM")))
		{
			sprintf((char *) &Out[strlen((char *) Out)], "%d,", In->Dcs);
		}

		sprintf((char *) &Out[strlen((char *) Out)], "%d,", In->NoPage);
		sprintf((char *) &Out[strlen((char *) Out)], "%d", In->NbPages);

		// <CR><LF>
		sprintf((char *) &Out[strlen((char *) Out)], "\r\n");

		atc_FormatCbPageForTe(&Out[strlen((char *) Out)], &DecCbPage);
	}
	// PDU mode
	else
	{
		UInt16 Size ;
		UInt16 Offset ;

		Size = DecCbPage.DataLen ;

		// show message status
		if (strcmp(CurAtCmd, "+CBM"))
		{
			sprintf((char *) &Out[strlen((char *) Out)], "%d,,", atc_SmsStatePdu[Status]);
		}

		// <length>
		sprintf((char *) &Out[strlen((char *) Out)], "%d", Size);

		// <CR><LF>
		sprintf((char *) &Out[strlen((char *) Out)], "\r\n");

		// page Header
		sprintf((char *) &Out[strlen((char *) Out)], "%04x%04x%02x%02x", In->Serial,
				In->MsgId, In->Dcs,
				((In->NoPage & 0x0F) << 4) | (In->NbPages & 0x0F));

		Offset = strlen((char*) Out);

		UTIL_HexDataToHexStr(&Out[Offset], In->Msg,Size);

		Out[Offset + 2 * Size] = '\0';
	}

	return(Res);
}



#undef __AT_UTSM_C__
